name: Build iOS TestFlight Distribution

on:
  push:
    branches: [ci/tauri-workflows]
  pull_request:
    branches: [ci/tauri-workflows]
  workflow_dispatch:
    inputs:
      release_notes:
        description: "Release notes for TestFlight"
        required: false
        default: ""

jobs:
  build-ios-testflight:
    runs-on: macos-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # Early validation: Test both API keys before building
      - name: Validate App Store Connect API Keys
        env:
          APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
          APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
          APP_STORE_CONNECT_API_KEY: ${{ secrets.APP_STORE_CONNECT_API_KEY }}
          APP_STORE_CONNECT_TESTER_API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_TESTER_API_KEY_ID }}
          APP_STORE_CONNECT_TESTER_API_KEY: ${{ secrets.APP_STORE_CONNECT_TESTER_API_KEY }}
          BUNDLE_ID: software.js.ui # Use known bundle ID for early validation
        run: |
          echo "üîç Early validation: Testing both App Store Connect API keys..."

          # Check if required API keys are available
          if [ -z "$APP_STORE_CONNECT_API_KEY_ID" ] || [ -z "$APP_STORE_CONNECT_API_KEY" ]; then
            echo "‚ùå Developer API key not configured for uploads"
            echo "üí° Please set APP_STORE_CONNECT_API_KEY_ID and APP_STORE_CONNECT_API_KEY secrets"
            exit 1
          fi

          echo "‚úÖ Developer API key secrets are configured"
          echo "üîë Developer API Key ID: $APP_STORE_CONNECT_API_KEY_ID"

          # Check tester management key only if testers are configured
          if [ -n "${{ vars.TESTFLIGHT_INTERNAL_TESTERS }}" ]; then
            if [ -z "$APP_STORE_CONNECT_TESTER_API_KEY_ID" ] || [ -z "$APP_STORE_CONNECT_TESTER_API_KEY" ]; then
              echo "‚ùå App Manager API key not configured for tester management"
              echo "üí° Please set APP_STORE_CONNECT_TESTER_API_KEY_ID and APP_STORE_CONNECT_TESTER_API_KEY secrets"
              exit 1
            fi
            echo "‚úÖ App Manager API key secrets are configured"
            echo "üîë App Manager API Key ID: $APP_STORE_CONNECT_TESTER_API_KEY_ID"
            echo "üë• Testers configured: ${{ vars.TESTFLIGHT_INTERNAL_TESTERS }}"
          else
            echo "‚ÑπÔ∏è No testers configured - skipping App Manager key validation"
          fi

          # Install Fastlane for API validation
          echo "üì¶ Installing Fastlane for API validation..."
          sudo gem install fastlane --no-document

          # Create API key files for validation
          mkdir -p ~/.appstoreconnect/private_keys

          # Developer key
          echo "$APP_STORE_CONNECT_API_KEY" | base64 -d > ~/.appstoreconnect/private_keys/AuthKey_$APP_STORE_CONNECT_API_KEY_ID.p8
          chmod 600 ~/.appstoreconnect/private_keys/AuthKey_$APP_STORE_CONNECT_API_KEY_ID.p8

          # App Manager key (if tester management is enabled)
          if [ -n "${{ vars.TESTFLIGHT_INTERNAL_TESTERS }}" ]; then
            echo "$APP_STORE_CONNECT_TESTER_API_KEY" | base64 -d > ~/.appstoreconnect/private_keys/AuthKey_$APP_STORE_CONNECT_TESTER_API_KEY_ID.p8
            chmod 600 ~/.appstoreconnect/private_keys/AuthKey_$APP_STORE_CONNECT_TESTER_API_KEY_ID.p8
          fi

          # Verify API key files were created correctly
          if [ ! -f ~/.appstoreconnect/private_keys/AuthKey_$APP_STORE_CONNECT_API_KEY_ID.p8 ]; then
            echo "‚ùå Failed to create Developer API key file"
            exit 1
          fi
          echo "‚úÖ Developer API key file created successfully"
          echo "üìè Developer key size: $(wc -c < ~/.appstoreconnect/private_keys/AuthKey_$APP_STORE_CONNECT_API_KEY_ID.p8) bytes"

          if [ -n "${{ vars.TESTFLIGHT_INTERNAL_TESTERS }}" ]; then
            if [ ! -f ~/.appstoreconnect/private_keys/AuthKey_$APP_STORE_CONNECT_TESTER_API_KEY_ID.p8 ]; then
              echo "‚ùå Failed to create App Manager API key file"
              exit 1
            fi
            echo "‚úÖ App Manager API key file created successfully"
            echo "üìè App Manager key size: $(wc -c < ~/.appstoreconnect/private_keys/AuthKey_$APP_STORE_CONNECT_TESTER_API_KEY_ID.p8) bytes"
          fi

          # Create minimal Fastlane setup for API validation
          mkdir -p fastlane

          cat > fastlane/Fastfile << 'EOF'
          opt_out_usage

          default_platform(:ios)

          platform :ios do
            desc "Validate Developer API key for uploads"
            lane :validate_developer_api do
              puts "üîç Validating Developer API key for TestFlight uploads..."
              
              # Get values from environment
              key_id = ENV["APP_STORE_CONNECT_API_KEY_ID"]
              issuer_id = ENV["APP_STORE_CONNECT_ISSUER_ID"]
              bundle_id = ENV["BUNDLE_ID"]
              
              puts "üîë Developer Key ID: #{key_id}"
              puts "üÜî Issuer ID: #{issuer_id}"
              puts "üì± Bundle ID: #{bundle_id}"
              
              if key_id.nil? || key_id.empty?
                puts "‚ùå APP_STORE_CONNECT_API_KEY_ID is not set or empty"
                raise "Missing required environment variable: APP_STORE_CONNECT_API_KEY_ID"
              end
              
              begin
                puts "üîç Testing Developer API key configuration..."
                
                # Validate API key file exists and is readable
                key_file = "#{Dir.home}/.appstoreconnect/private_keys/AuthKey_#{key_id}.p8"
                unless File.exist?(key_file) && File.readable?(key_file)
                  raise "API key file not found or not readable: #{key_file}"
                end
                
                puts "‚úÖ Developer API key file is accessible"
                puts "üîë Key file: #{key_file}"
                puts "üìè Key file size: #{File.size(key_file)} bytes"
                
                # Test upload permissions using upload_to_testflight (dry run)
                begin
                  puts "üîÑ Testing upload permissions with upload_to_testflight..."
                  
                  # Use direct api_key parameter to avoid hash/string conflicts
                  upload_to_testflight(
                    app_identifier: bundle_id,
                    api_key: {
                      key_id: key_id,
                      issuer_id: issuer_id,
                      key_filepath: key_file
                    },
                    skip_submission: true,
                    skip_waiting_for_build_processing: true
                  )
                  
                  puts "‚úÖ Upload_to_testflight validation successful"
                  
                rescue => upload_error
                  # Expected to fail without IPA, but should NOT fail with auth errors
                  error_message = upload_error.message.downcase
                  
                  if error_message.include?("unauthorized") || 
                     error_message.include?("forbidden") || 
                     error_message.include?("invalid") ||
                     error_message.include?("authentication") ||
                     error_message.include?("provider does not exist")
                    puts "‚ùå Developer API authentication failed: #{upload_error.message}"
                    raise "Developer API key authentication failed - check credentials and permissions"
                  elsif error_message.include?("ipa") || error_message.include?("file") || error_message.include?("build")
                    puts "‚úÖ Developer API key authentication succeeded (expected upload error: no IPA provided)"
                  else
                    puts "‚úÖ Developer API key authentication succeeded (expected error: #{upload_error.message})"
                  end
                end
                
                puts "üéâ Developer API key validation completed!"
                puts "üí° Developer API key is properly configured for uploads"
                
              rescue => e
                puts "‚ùå Developer API validation failed: #{e.message}"
                puts "üí° Check your APP_STORE_CONNECT_API_KEY credentials"
                puts "üí° Ensure the API key has Developer role and app access"
                raise e
              end
            end
            
            desc "Validate App Manager API key for tester management"
            lane :validate_tester_api do
              puts "üîç Validating App Manager API key for tester management..."
              
              # Get values from environment
              key_id = ENV["APP_STORE_CONNECT_TESTER_API_KEY_ID"]
              issuer_id = ENV["APP_STORE_CONNECT_ISSUER_ID"]
              bundle_id = ENV["BUNDLE_ID"]
              
              puts "üîë App Manager Key ID: #{key_id}"
              puts "üÜî Issuer ID: #{issuer_id}"
              puts "üì± Bundle ID: #{bundle_id}"
              
              if key_id.nil? || key_id.empty?
                puts "‚ùå APP_STORE_CONNECT_TESTER_API_KEY_ID is not set or empty"
                raise "Missing required environment variable: APP_STORE_CONNECT_TESTER_API_KEY_ID"
              end
              
              begin
                puts "üîç Testing App Manager API key configuration..."
                
                # Validate API key file exists and is readable
                key_file = "#{Dir.home}/.appstoreconnect/private_keys/AuthKey_#{key_id}.p8"
                unless File.exist?(key_file) && File.readable?(key_file)
                  raise "API key file not found or not readable: #{key_file}"
                end
                
                puts "‚úÖ App Manager API key file is accessible"
                puts "üîë Key file: #{key_file}"
                puts "üìè Key file size: #{File.size(key_file)} bytes"
                
                # Test tester management permissions using pilot
                begin
                  puts "üîÑ Testing tester management permissions with pilot..."
                  
                  # Use direct api_key parameter to avoid hash/string conflicts
                  pilot(
                    app_identifier: bundle_id,
                    api_key: {
                      key_id: key_id,
                      issuer_id: issuer_id,
                      key_filepath: key_file
                    },
                    skip_submission: true,
                    skip_waiting_for_build_processing: true
                  )
                  
                  puts "‚úÖ Pilot validation successful"
                  
                rescue => pilot_error
                  # Expected to fail without builds, but should NOT fail with auth errors
                  error_message = pilot_error.message.downcase
                  
                  if error_message.include?("unauthorized") || 
                     error_message.include?("forbidden") || 
                     error_message.include?("invalid") ||
                     error_message.include?("authentication")
                    puts "‚ùå App Manager API authentication failed: #{pilot_error.message}"
                    raise "App Manager API key authentication failed - check credentials and App Manager role"
                  else
                    puts "‚úÖ App Manager API key authentication succeeded (expected pilot error: #{pilot_error.message})"
                  end
                end
                
                puts "üéâ App Manager API key validation completed!"
                puts "üí° App Manager API key is properly configured for tester management"
                
              rescue => e
                puts "‚ùå App Manager API validation failed: #{e.message}"
                puts "üí° Check your APP_STORE_CONNECT_TESTER_API_KEY credentials"
                puts "üí° Ensure the API key has App Manager role in App Store Connect"
                raise e
              end
            end
          end
          EOF

          # Create Appfile
          cat > fastlane/Appfile << EOF
          app_identifier("$BUNDLE_ID")
          EOF

          # Export environment variables for Fastlane
          export APP_STORE_CONNECT_API_KEY_ID="$APP_STORE_CONNECT_API_KEY_ID"
          export APP_STORE_CONNECT_TESTER_API_KEY_ID="$APP_STORE_CONNECT_TESTER_API_KEY_ID"
          export APP_STORE_CONNECT_ISSUER_ID="$APP_STORE_CONNECT_ISSUER_ID"
          export BUNDLE_ID="$BUNDLE_ID"

          echo "üîç Debug: Environment variables:"
          echo "   APP_STORE_CONNECT_API_KEY_ID: $APP_STORE_CONNECT_API_KEY_ID"
          echo "   APP_STORE_CONNECT_TESTER_API_KEY_ID: $APP_STORE_CONNECT_TESTER_API_KEY_ID"
          echo "   APP_STORE_CONNECT_ISSUER_ID: $APP_STORE_CONNECT_ISSUER_ID"
          echo "   BUNDLE_ID: $BUNDLE_ID"

          # Run validations
          echo "üöÄ Testing Developer API key..."
          if APP_STORE_CONNECT_API_KEY_ID="$APP_STORE_CONNECT_API_KEY_ID" \
             APP_STORE_CONNECT_ISSUER_ID="$APP_STORE_CONNECT_ISSUER_ID" \
             BUNDLE_ID="$BUNDLE_ID" \
             fastlane ios validate_developer_api; then
            echo "üéâ Developer API key validation passed!"
          else
            echo "‚ùå Developer API key validation failed"
            echo "üõë Stopping workflow to avoid wasting CI time"
            exit 1
          fi

          # Test App Manager key only if testers are configured
          if [ -n "${{ vars.TESTFLIGHT_INTERNAL_TESTERS }}" ]; then
            echo "üöÄ Testing App Manager API key..."
            if APP_STORE_CONNECT_TESTER_API_KEY_ID="$APP_STORE_CONNECT_TESTER_API_KEY_ID" \
               APP_STORE_CONNECT_ISSUER_ID="$APP_STORE_CONNECT_ISSUER_ID" \
               BUNDLE_ID="$BUNDLE_ID" \
               fastlane ios validate_tester_api; then
              echo "üéâ App Manager API key validation passed!"
            else
              echo "‚ùå App Manager API key validation failed"
              echo "üõë Stopping workflow to avoid wasting CI time"
              exit 1
            fi
          else
            echo "‚ÑπÔ∏è Skipping App Manager API key validation (no testers configured)"
          fi

          # Clean up validation files
          rm -rf fastlane
          rm -f ~/.appstoreconnect/private_keys/AuthKey_$APP_STORE_CONNECT_API_KEY_ID.p8
          if [ -n "${{ vars.TESTFLIGHT_INTERNAL_TESTERS }}" ]; then
            rm -f ~/.appstoreconnect/private_keys/AuthKey_$APP_STORE_CONNECT_TESTER_API_KEY_ID.p8
          fi

          echo "‚úÖ Early validation completed successfully - both API keys are working!"

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: aarch64-apple-ios

      - name: Setup Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: latest-stable

      - name: Install iOS Dependencies
        run: rustup target add aarch64-apple-ios

      - name: Install dependencies
        run: bun install

      - name: Build frontend
        run: bun run build

      # Extract project configuration from Tauri config
      - name: Extract project configuration
        run: |
          # Read bundle ID and app name from Tauri config
          BUNDLE_ID=$(jq -r '.identifier' src-tauri/tauri.conf.json)
          APP_NAME=$(jq -r '.productName' src-tauri/tauri.conf.json)

          echo "BUNDLE_ID=$BUNDLE_ID" >> $GITHUB_ENV
          echo "APP_NAME=$APP_NAME" >> $GITHUB_ENV

          echo "üìã Detected Bundle ID: $BUNDLE_ID"
          echo "üìã Detected App Name: $APP_NAME"

      # Automated version management for TestFlight
      - name: Automated Version Management
        run: |
          echo "üî¢ Setting up automated versioning for TestFlight..."

          # Get current version from Tauri config
          CURRENT_VERSION=$(jq -r '.version // "1.0.0"' src-tauri/tauri.conf.json)

          # Create new build number using GitHub run number for uniqueness
          # Format: YYYYMMDD.RUN_NUMBER (e.g., 20250109.123)
          BUILD_DATE=$(date +%Y%m%d)
          NEW_BUILD_NUMBER="${BUILD_DATE}.${{ github.run_number }}"

          # For TestFlight, we can also use a simpler incrementing scheme
          # Alternative: just use run number if you prefer shorter build numbers
          # NEW_BUILD_NUMBER="${{ github.run_number }}"

          echo "MARKETING_VERSION=$CURRENT_VERSION" >> $GITHUB_ENV
          echo "BUNDLE_VERSION=$NEW_BUILD_NUMBER" >> $GITHUB_ENV

          echo "üì± Marketing Version (CFBundleShortVersionString): $CURRENT_VERSION"
          echo "üî¢ Bundle Version (CFBundleVersion): $NEW_BUILD_NUMBER"
          echo "üèÉ GitHub Run Number: ${{ github.run_number }}"

          # Update Tauri config with new version scheme
          # Keep the marketing version, but prepare for bundle version override
          jq --arg version "$CURRENT_VERSION" '.version = $version' src-tauri/tauri.conf.json > tmp.json && mv tmp.json src-tauri/tauri.conf.json

          echo "‚úÖ Version configuration prepared"

      # Import App Store distribution certificate
      - name: Setup iOS App Store signing
        id: ios-signing
        uses: apple-actions/import-codesign-certs@v2
        with:
          p12-file-base64: ${{ secrets.IOS_APPSTORE_CERTIFICATE }}
          p12-password: ${{ secrets.IOS_APPSTORE_CERTIFICATE_PASSWORD }}
          keychain-password: ${{ github.run_id }}
          create-keychain: true

      # Install App Store provisioning profile
      - name: Install App Store provisioning profile
        run: |
          mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
          echo -n "${{ secrets.IOS_APPSTORE_PROVISIONING_PROFILE }}" | base64 --decode > appstore.mobileprovision

          # Verify the provisioning profile was decoded properly
          if [ ! -s appstore.mobileprovision ]; then
            echo "‚ùå Failed to decode provisioning profile - check IOS_APPSTORE_PROVISIONING_PROFILE secret"
            exit 1
          fi

          # Extract UUID from provisioning profile for proper naming
          PROFILE_UUID=$(security cms -D -i appstore.mobileprovision | plutil -extract UUID xml1 - -o - | sed -n 's/.*<string>\(.*\)<\/string>.*/\1/p')

          if [ -z "$PROFILE_UUID" ]; then
            echo "‚ùå Failed to extract UUID from provisioning profile"
            echo "Profile content preview:"
            head -20 appstore.mobileprovision
            exit 1
          fi

          echo "PROFILE_UUID=$PROFILE_UUID" >> $GITHUB_ENV
          echo "üìã Extracted Profile UUID: $PROFILE_UUID"

          # Install with proper UUID naming
          cp appstore.mobileprovision ~/Library/MobileDevice/Provisioning\ Profiles/$PROFILE_UUID.mobileprovision

          # Verify installation
          if [ -f ~/Library/MobileDevice/Provisioning\ Profiles/$PROFILE_UUID.mobileprovision ]; then
            echo "‚úÖ Provisioning profile installed successfully"
          else
            echo "‚ùå Failed to install provisioning profile"
            exit 1
          fi

          # Clean up
          rm appstore.mobileprovision

      # Add iOS team configuration to Tauri config
      - name: Add iOS section with developmentTeam
        run: |
          if grep -q '"iOS": {' src-tauri/tauri.conf.json; then
            sed -i '' 's/"developmentTeam": "[^"]*"/"developmentTeam": "${{ secrets.APPLE_TEAM_ID }}"/' src-tauri/tauri.conf.json
          else
            jq '.bundle.iOS = {"developmentTeam": "${{ secrets.APPLE_TEAM_ID }}"}' src-tauri/tauri.conf.json > tmp.json && mv tmp.json src-tauri/tauri.conf.json
          fi

      # Initialize Tauri iOS project
      - name: Initialize Tauri iOS
        run: bun run tauri ios init

      # Add export compliance to skip manual review
      - name: Add export compliance to Info.plist
        run: |
          INFO_PLIST="src-tauri/gen/apple/app_iOS/Info.plist"

          if [ -f "$INFO_PLIST" ]; then
            echo "üìù Adding export compliance to Info.plist..."
            
            # Add ITSAppUsesNonExemptEncryption = NO to bypass export compliance dialog
            /usr/libexec/PlistBuddy -c "Add :ITSAppUsesNonExemptEncryption bool false" "$INFO_PLIST" 2>/dev/null || \
            /usr/libexec/PlistBuddy -c "Set :ITSAppUsesNonExemptEncryption false" "$INFO_PLIST"
            
            echo "‚úÖ Export compliance added to Info.plist"
            echo "üîç Verifying Info.plist entry:"
            /usr/libexec/PlistBuddy -c "Print :ITSAppUsesNonExemptEncryption" "$INFO_PLIST"
          else
            echo "‚ö†Ô∏è Info.plist not found at $INFO_PLIST"
          fi

      # Apply version configuration to iOS project
      - name: Apply automated versioning to iOS project
        run: |
          INFO_PLIST="src-tauri/gen/apple/app_iOS/Info.plist"

          if [ -f "$INFO_PLIST" ]; then
            echo "üìù Applying automated versioning to iOS project..."
            
            # Set CFBundleShortVersionString (marketing version)
            /usr/libexec/PlistBuddy -c "Set :CFBundleShortVersionString ${{ env.MARKETING_VERSION }}" "$INFO_PLIST"
            
            # Set CFBundleVersion (bundle version) - this must be unique for each TestFlight upload
            /usr/libexec/PlistBuddy -c "Set :CFBundleVersion ${{ env.BUNDLE_VERSION }}" "$INFO_PLIST"
            
            echo "‚úÖ Version configuration applied to Info.plist"
            echo "üì± Marketing Version: ${{ env.MARKETING_VERSION }}"
            echo "üî¢ Bundle Version: ${{ env.BUNDLE_VERSION }}"
            
            # Verify the changes
            echo "üîç Current Info.plist versions:"
            /usr/libexec/PlistBuddy -c "Print :CFBundleShortVersionString" "$INFO_PLIST"
            /usr/libexec/PlistBuddy -c "Print :CFBundleVersion" "$INFO_PLIST"
          else
            echo "‚ùå Info.plist not found at $INFO_PLIST"
            echo "üîç Looking for Info.plist in alternative locations:"
            find src-tauri/gen -name "Info.plist" -type f || echo "No Info.plist found"
            exit 1
          fi

      # Apply App Store signing fixes
      - name: Apply App Store signing fixes
        run: |
          PBXPROJ_FILE="src-tauri/gen/apple/app.xcodeproj/project.pbxproj"

          # Fix bundle ID to match Tauri configuration
          CURRENT_BUNDLE_ID=$(grep -o "PRODUCT_BUNDLE_IDENTIFIER = [^;]*" "$PBXPROJ_FILE" | head -1 | sed 's/PRODUCT_BUNDLE_IDENTIFIER = //')
          if [ -n "$CURRENT_BUNDLE_ID" ] && [ "$CURRENT_BUNDLE_ID" != "${{ env.BUNDLE_ID }}" ]; then
            ESCAPED_CURRENT=$(echo "$CURRENT_BUNDLE_ID" | sed 's/\./\\./g')
            sed -i '' "s/$ESCAPED_CURRENT/${{ env.BUNDLE_ID }}/g" "$PBXPROJ_FILE"
          fi

          # Switch to manual signing
          sed -i '' 's/CODE_SIGN_STYLE = Automatic;/CODE_SIGN_STYLE = Manual;/g' "$PBXPROJ_FILE"
          sed -i '' 's/"CODE_SIGN_STYLE\[sdk=iphoneos\*\]" = Automatic;/"CODE_SIGN_STYLE[sdk=iphoneos*]" = Manual;/g' "$PBXPROJ_FILE"
          sed -i '' 's/ProvisioningStyle = Automatic;/ProvisioningStyle = Manual;/g' "$PBXPROJ_FILE"

          # Set App Store code sign identity
          sed -i '' 's/"CODE_SIGN_IDENTITY\[sdk=iphoneos\*\]" = "iPhone Developer";/"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "Apple Distribution";/g' "$PBXPROJ_FILE"
          sed -i '' 's/CODE_SIGN_IDENTITY = "iPhone Developer";/CODE_SIGN_IDENTITY = "Apple Distribution";/g' "$PBXPROJ_FILE"
          sed -i '' 's/"iPhone Developer"/"Apple Distribution"/g' "$PBXPROJ_FILE"
          sed -i '' 's/"iPhone Distribution"/"Apple Distribution"/g' "$PBXPROJ_FILE"

          # Set development team
          sed -i '' 's/DEVELOPMENT_TEAM = "";/DEVELOPMENT_TEAM = "${{ secrets.APPLE_TEAM_ID }}";/g' "$PBXPROJ_FILE"
          if ! grep -q "DEVELOPMENT_TEAM" "$PBXPROJ_FILE"; then
            sed -i '' '/CODE_SIGN_IDENTITY.*Apple Distribution/a\
          				DEVELOPMENT_TEAM = "${{ secrets.APPLE_TEAM_ID }}";' "$PBXPROJ_FILE"
          fi

          # Add provisioning profile specifier
          sed -i '' '/PROVISIONING_PROFILE_SPECIFIER/d' "$PBXPROJ_FILE"
          sed -i '' '/CODE_SIGN_IDENTITY.*Apple Distribution/a\
          				PROVISIONING_PROFILE_SPECIFIER = "'$PROFILE_UUID'";' "$PBXPROJ_FILE"

          # Remove old provisioning profile settings
          sed -i '' '/PROVISIONING_PROFILE = /d' "$PBXPROJ_FILE"

      # Create export options for App Store
      - name: Create exportOptions.plist
        run: |
          cat > exportOptions.plist << EOF
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>method</key>
              <string>app-store</string>
              <key>teamID</key>
              <string>${{ secrets.APPLE_TEAM_ID }}</string>
              <key>uploadBitcode</key>
              <false/>
              <key>uploadSymbols</key>
              <true/>
              <key>provisioningProfiles</key>
              <dict>
                  <key>${{ env.BUNDLE_ID }}</key>
                  <string>${PROFILE_UUID}</string>
              </dict>
          </dict>
          </plist>
          EOF

          # Copy to multiple locations where Tauri might look for it
          cp exportOptions.plist src-tauri/
          cp exportOptions.plist src-tauri/gen/apple/
          mkdir -p src-tauri/gen/apple/app.xcodeproj
          cp exportOptions.plist src-tauri/gen/apple/app.xcodeproj/

      # Build for App Store
      - name: Build iOS app for App Store
        env:
          DEVELOPER_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          cd src-tauri

          echo "üî® Starting Tauri iOS build..."
          echo "Working directory: $(pwd)"
          echo "Bundle ID: ${{ env.BUNDLE_ID }}"
          echo "App Name: ${{ env.APP_NAME }}"

          # Run Tauri build (may fail on export but still create xcarchive)
          echo "üöÄ Running Tauri iOS build..."
          BUILD_SUCCESS=false
          if bun tauri ios build --export-method app-store-connect; then
            BUILD_SUCCESS=true
            echo "‚úÖ Tauri build and export completed successfully"
          else
            echo "‚ö†Ô∏è Tauri export failed, but checking for xcarchive..."
          fi

          # Always check for IPA files first
          echo "üîç Searching for IPA files in all locations..."

          # Check workspace root first (where xcodebuild exports)
          find "$GITHUB_WORKSPACE" -name "*.ipa" -type f -exec ls -la {} \; 2>/dev/null || echo "No IPA in workspace root"

          # Check src-tauri directory
          find . -name "*.ipa" -type f -exec ls -la {} \; 2>/dev/null || echo "No IPA in src-tauri"

          # Look for IPA in common locations
          IPA_LOCATIONS=(
            "$GITHUB_WORKSPACE/*.ipa"
            "./*.ipa"
            "./target/*.ipa"
            "./gen/apple/*.ipa"
            "../*.ipa"
          )

          FOUND_IPA=""
          for pattern in "${IPA_LOCATIONS[@]}"; do
            for file in $pattern; do
              if [ -f "$file" ]; then
                FOUND_IPA="$file"
                echo "üì¶ Found IPA: $FOUND_IPA"
                break 2
              fi
            done
          done

          # If no IPA found, try manual export from xcarchive
          if [ -z "$FOUND_IPA" ]; then
            echo "üîç No IPA found, looking for xcarchive to export manually..."
            
            # Find xcarchive
            XCARCHIVE_PATH=$(find . -name "*.xcarchive" -type d | head -n 1)
            if [ -n "$XCARCHIVE_PATH" ]; then
              echo "üì¶ Found xcarchive: $XCARCHIVE_PATH"
              
              # Check xcarchive contents
              echo "üîç xcarchive contents:"
              find "$XCARCHIVE_PATH" -type f -name "*.app" | head -5
              
              # Manual export using xcodebuild
              IPA_NAME="${APP_NAME// /_}_TestFlight.ipa"
              EXPORT_PATH="$GITHUB_WORKSPACE/export"
              mkdir -p "$EXPORT_PATH"
              
              echo "üîÑ Manually exporting IPA from xcarchive..."
              echo "Archive: $XCARCHIVE_PATH"
              echo "Export path: $EXPORT_PATH"
              echo "Export options: $GITHUB_WORKSPACE/exportOptions.plist"
              
              # Show export options for debugging
              echo "üìã Export options content:"
              cat "$GITHUB_WORKSPACE/exportOptions.plist"
              
              if xcodebuild -exportArchive \
                -archivePath "$XCARCHIVE_PATH" \
                -exportPath "$EXPORT_PATH" \
                -exportOptionsPlist "$GITHUB_WORKSPACE/exportOptions.plist" \
                -verbose; then
                
                echo "‚úÖ Manual export succeeded"
                
                # Find the exported IPA
                EXPORTED_IPA=$(find "$EXPORT_PATH" -name "*.ipa" -type f | head -n 1)
                if [ -n "$EXPORTED_IPA" ]; then
                  echo "üì¶ Found exported IPA: $EXPORTED_IPA"
                  FOUND_IPA="$EXPORTED_IPA"
                else
                  echo "‚ùå No IPA found after export"
                  echo "üîç Export directory contents:"
                  ls -la "$EXPORT_PATH" || echo "Export directory not found"
                fi
              else
                echo "‚ùå Manual export also failed"
                echo "üîç Checking provisioning profile setup..."
                
                # Debug provisioning profiles
                echo "üîç Installed provisioning profiles:"
                ls -la ~/Library/MobileDevice/Provisioning\ Profiles/ 2>/dev/null || echo "No provisioning profiles directory"
                
                # Check if our profile is there
                if [ -n "${{ env.PROFILE_UUID }}" ]; then
                  PROFILE_FILE=~/Library/MobileDevice/Provisioning\ Profiles/${{ env.PROFILE_UUID }}.mobileprovision
                  if [ -f "$PROFILE_FILE" ]; then
                    echo "‚úÖ Our profile exists: $PROFILE_FILE"
                    echo "üîç Profile info:"
                    security cms -D -i "$PROFILE_FILE" | head -20
                  else
                    echo "‚ùå Our profile missing: $PROFILE_FILE"
                  fi
                else
                  echo "‚ùå PROFILE_UUID is empty - provisioning profile step failed"
                fi
                
                # Check certificates
                echo "üîç Available certificates:"
                security find-identity -p codesigning -v
                
                exit 1
              fi
            else
              echo "‚ùå No xcarchive found either"
              echo "üîç Looking for any build artifacts:"
              find . -type f -name "*" | grep -E "\.(app|xcarchive)$" || echo "No iOS build artifacts found"
              exit 1
            fi
          fi

          # If we found an IPA, prepare it
          if [ -n "$FOUND_IPA" ]; then
            echo "‚úÖ IPA found at: $FOUND_IPA"
            echo "üìè IPA size: $(ls -lh "$FOUND_IPA" | awk '{print $5}')"
            
            # Copy to consistent location if needed
            IPA_NAME="${APP_NAME// /_}_TestFlight.ipa"
            TARGET_PATH="$GITHUB_WORKSPACE/$IPA_NAME"
            
            if [ "$FOUND_IPA" != "$TARGET_PATH" ]; then
              echo "üìã Copying IPA to: $TARGET_PATH"
              cp "$FOUND_IPA" "$TARGET_PATH"
            fi
            
            # Verify final IPA
            if [ -f "$TARGET_PATH" ]; then
              echo "‚úÖ Final IPA ready: $TARGET_PATH"
              echo "üìè Final size: $(ls -lh "$TARGET_PATH" | awk '{print $5}')"
              echo "IPA_PATH=$TARGET_PATH" >> $GITHUB_ENV
            else
              echo "‚ùå Failed to prepare final IPA"
              exit 1
            fi
          else
            echo "‚ùå No IPA could be created or found!"
            exit 1
          fi

      # Verify IPA before upload
      - name: Verify IPA before upload
        run: |
          echo "üîç Verifying IPA file before upload..."

          if [ -z "${{ env.IPA_PATH }}" ]; then
            echo "‚ùå IPA_PATH environment variable is not set"
            exit 1
          fi

          if [ ! -f "${{ env.IPA_PATH }}" ]; then
            echo "‚ùå IPA file not found at: ${{ env.IPA_PATH }}"
            echo "üîç Workspace contents:"
            ls -la "$GITHUB_WORKSPACE"
            echo "üîç Looking for any IPA files:"
            find "$GITHUB_WORKSPACE" -name "*.ipa" -type f -exec ls -la {} \; || echo "No IPA files found"
            exit 1
          fi

          echo "‚úÖ IPA file verified: ${{ env.IPA_PATH }}"
          echo "üìè File size: $(ls -lh "${{ env.IPA_PATH }}" | awk '{print $5}')"
          echo "üîê File permissions: $(ls -l "${{ env.IPA_PATH }}" | awk '{print $1}')"

      # Upload to TestFlight using Fastlane
      - name: Upload to TestFlight using Fastlane
        env:
          APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
          APP_STORE_CONNECT_API_KEY: ${{ secrets.APP_STORE_CONNECT_API_KEY }}
          APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
          BUNDLE_ID: ${{ env.BUNDLE_ID }}
          IPA_PATH: ${{ env.IPA_PATH }}
          APP_NAME: ${{ env.APP_NAME }}
          MARKETING_VERSION: ${{ env.MARKETING_VERSION }}
          BUNDLE_VERSION: ${{ env.BUNDLE_VERSION }}
        run: |
          echo "üöÄ Uploading to TestFlight using Fastlane and Developer API key..."
          echo "üîë Developer API Key ID: $APP_STORE_CONNECT_API_KEY_ID"

          # Check if required secrets are available
          if [ -z "$APP_STORE_CONNECT_API_KEY_ID" ] || [ -z "$APP_STORE_CONNECT_API_KEY" ]; then
            echo "‚ùå Developer API key not configured for uploads"
            echo "üí° Please check APP_STORE_CONNECT_API_KEY_ID and APP_STORE_CONNECT_API_KEY secrets"
            exit 1
          fi

          # Install Fastlane if not already available
          if ! command -v fastlane &> /dev/null; then
            echo "üì¶ Installing Fastlane..."
            sudo gem install fastlane --no-document
          fi

          # Setup API key file for upload
          mkdir -p ~/.appstoreconnect/private_keys
          echo "$APP_STORE_CONNECT_API_KEY" | base64 -d > ~/.appstoreconnect/private_keys/AuthKey_$APP_STORE_CONNECT_API_KEY_ID.p8
          chmod 600 ~/.appstoreconnect/private_keys/AuthKey_$APP_STORE_CONNECT_API_KEY_ID.p8

          if [ ! -f ~/.appstoreconnect/private_keys/AuthKey_$APP_STORE_CONNECT_API_KEY_ID.p8 ]; then
            echo "‚ùå Failed to create Developer API key file for upload"
            exit 1
          fi

          echo "‚úÖ Developer API key file setup complete"
          echo "üìè Key file size: $(wc -c < ~/.appstoreconnect/private_keys/AuthKey_$APP_STORE_CONNECT_API_KEY_ID.p8) bytes"

          # Generate release notes
          CUSTOM_NOTES="${{ github.event.inputs.release_notes }}"
          if [ -n "$CUSTOM_NOTES" ]; then
            RELEASE_NOTES="$CUSTOM_NOTES"
          else
            RELEASE_NOTES="üöÄ New $APP_NAME iOS Build - Version $MARKETING_VERSION (Build $BUNDLE_VERSION)

          üì± Built from: ${{ github.ref_name }}
          üîó Commit: ${{ github.sha }}
          üë§ Author: ${{ github.actor }}
          üèÉ Build Number: ${{ github.run_number }}

          üìù Changes in this build:
          ${{ github.event.head_commit.message }}

          üíæ Download from TestFlight to test the latest features!"
          fi

          # Create temporary file for release notes
          echo "$RELEASE_NOTES" > /tmp/release_notes.txt
          echo "üìù Release notes prepared (${#RELEASE_NOTES} characters)"

          # Create Fastlane setup for upload
          mkdir -p fastlane

          cat > fastlane/Fastfile << 'EOF'
          opt_out_usage

          default_platform(:ios)

          platform :ios do
            desc "Upload IPA to TestFlight"
            lane :upload_testflight do
              puts "üöÄ Uploading to TestFlight using Fastlane..."
              
              # Get values from environment
              key_id = ENV["APP_STORE_CONNECT_API_KEY_ID"]
              issuer_id = ENV["APP_STORE_CONNECT_ISSUER_ID"]
              bundle_id = ENV["BUNDLE_ID"]
              ipa_path = ENV["IPA_PATH"]
              
              puts "üîë Developer Key ID: #{key_id}"
              puts "üÜî Issuer ID: #{issuer_id}"
              puts "üì± Bundle ID: #{bundle_id}"
              puts "üì¶ IPA Path: #{ipa_path}"
              puts "üìè IPA file size: #{File.size(ipa_path)} bytes"
              
              # Build key file path using same pattern as working tester management
              key_file = "#{Dir.home}/.appstoreconnect/private_keys/AuthKey_#{key_id}.p8"
              puts "üîë Key File Path: #{key_file}"
              
              unless File.exist?(key_file)
                puts "‚ùå API key file not found: #{key_file}"
                raise "API key file not found: #{key_file}"
              end
              
              puts "‚úÖ API key file verified: #{key_file} (#{File.size(key_file)} bytes)"
              
              begin
                puts "üîÑ Starting TestFlight upload with Developer key..."
                
                # Use the EXACT same pattern as the working tester management step
                upload_to_testflight(
                  ipa: ipa_path,
                  app_identifier: bundle_id,
                  api_key: {
                    key_id: key_id,
                    issuer_id: issuer_id,
                    key_filepath: key_file
                  },
                  skip_submission: false,
                  skip_waiting_for_build_processing: true,
                  notify_external_testers: false,
                  distribute_external: false
                )
                
                puts "üéâ Successfully uploaded to TestFlight with Developer key!"
                
              rescue => e
                puts "‚ùå Developer key upload failed: #{e.message}"
                
                # Fallback: Try with App Manager key if available (same as tester management)
                fallback_key_id = ENV["APP_STORE_CONNECT_TESTER_API_KEY_ID"]
                if fallback_key_id && !fallback_key_id.empty?
                  puts "üîÑ Trying fallback with App Manager key: #{fallback_key_id}"
                  
                  fallback_key_file = "#{Dir.home}/.appstoreconnect/private_keys/AuthKey_#{fallback_key_id}.p8"
                  
                  if File.exist?(fallback_key_file)
                    begin
                      upload_to_testflight(
                        ipa: ipa_path,
                        app_identifier: bundle_id,
                        api_key: {
                          key_id: fallback_key_id,
                          issuer_id: issuer_id,
                          key_filepath: fallback_key_file
                        },
                        skip_submission: false,
                        skip_waiting_for_build_processing: true,
                        notify_external_testers: false,
                        distribute_external: false
                      )
                      
                      puts "üéâ Successfully uploaded to TestFlight with App Manager key!"
                      
                    rescue => e2
                      puts "‚ùå Both keys failed:"
                      puts "   Developer key error: #{e.message}"
                      puts "   App Manager key error: #{e2.message}"
                      raise e2
                    end
                  else
                    puts "‚ùå Fallback key file not found: #{fallback_key_file}"
                    raise e
                  end
                else
                  puts "‚ùå No fallback App Manager key available"
                  raise e
                end
              end
            end
          end
          EOF

          # Create Appfile
          cat > fastlane/Appfile << EOF
          app_identifier("$BUNDLE_ID")
          EOF

          # Export environment variables for Fastlane
          export APP_STORE_CONNECT_API_KEY_ID="$APP_STORE_CONNECT_API_KEY_ID"
          export APP_STORE_CONNECT_ISSUER_ID="$APP_STORE_CONNECT_ISSUER_ID"
          export BUNDLE_ID="$BUNDLE_ID"
          export IPA_PATH="$IPA_PATH"

          echo "üîç Debug: Environment variables for upload:"
          echo "   APP_STORE_CONNECT_API_KEY_ID: $APP_STORE_CONNECT_API_KEY_ID"
          echo "   APP_STORE_CONNECT_ISSUER_ID: $APP_STORE_CONNECT_ISSUER_ID"
          echo "   BUNDLE_ID: $BUNDLE_ID"
          echo "   IPA_PATH: $IPA_PATH"

          # Run Fastlane upload
          echo "üöÄ Running Fastlane TestFlight upload..."
          if APP_STORE_CONNECT_API_KEY_ID="$APP_STORE_CONNECT_API_KEY_ID" \
             APP_STORE_CONNECT_ISSUER_ID="$APP_STORE_CONNECT_ISSUER_ID" \
             BUNDLE_ID="$BUNDLE_ID" \
             IPA_PATH="$IPA_PATH" \
             fastlane ios upload_testflight; then
            echo "üéâ Fastlane TestFlight upload completed successfully!"
            echo "‚úÖ Build is now processing in TestFlight"
          else
            echo "‚ùå Fastlane TestFlight upload failed"
            echo "üí° Check logs above for specific error details"
            exit 1
          fi

          # Clean up
          rm -rf fastlane
          rm -f ~/.appstoreconnect/private_keys/AuthKey_$APP_STORE_CONNECT_API_KEY_ID.p8
          rm -f /tmp/release_notes.txt

          echo "üßπ Cleanup completed"

      # Add internal testers (if configured)
      - name: Notify internal testers
        continue-on-error: true
        run: |
          if [ -n "${{ vars.TESTFLIGHT_INTERNAL_TESTERS }}" ]; then
            echo "üìß Internal testers configured: ${{ vars.TESTFLIGHT_INTERNAL_TESTERS }}"
            echo "üîÑ Testers will be automatically notified when build is processed"
            echo "‚è±Ô∏è  Processing usually takes 5-15 minutes"
          else
            echo "‚ÑπÔ∏è No internal testers configured via TESTFLIGHT_INTERNAL_TESTERS variable"
            echo "üí° Add testers manually in App Store Connect ‚Üí TestFlight ‚Üí Internal Testing"
          fi

      # Manage TestFlight Internal Testers using Fastlane
      - name: Manage TestFlight Internal Testers (Fastlane)
        if: vars.TESTFLIGHT_INTERNAL_TESTERS # Enable step only if testers are configured
        env:
          APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
          APP_STORE_CONNECT_API_KEY: ${{ secrets.APP_STORE_CONNECT_API_KEY }}
          APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
          APP_STORE_CONNECT_TESTER_API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_TESTER_API_KEY_ID }}
          APP_STORE_CONNECT_TESTER_API_KEY: ${{ secrets.APP_STORE_CONNECT_TESTER_API_KEY }}
          BUNDLE_ID: ${{ env.BUNDLE_ID }}
          TESTFLIGHT_TESTERS: ${{ vars.TESTFLIGHT_INTERNAL_TESTERS }}
        run: |
          echo "üöÄ Managing TestFlight testers using Fastlane..."

          # Check if tester management API key is available
          if [ -z "$APP_STORE_CONNECT_TESTER_API_KEY_ID" ] || [ -z "$APP_STORE_CONNECT_TESTER_API_KEY" ]; then
            echo "‚ö†Ô∏è App Manager API key not configured for tester management"
            echo "üí° Using Developer API key (may have limited permissions)"
            TESTER_KEY_ID="$APP_STORE_CONNECT_API_KEY_ID"
            TESTER_API_KEY="$APP_STORE_CONNECT_API_KEY"
          else
            echo "‚úÖ Using dedicated App Manager API key for tester management"
            TESTER_KEY_ID="$APP_STORE_CONNECT_TESTER_API_KEY_ID"
            TESTER_API_KEY="$APP_STORE_CONNECT_TESTER_API_KEY"
          fi

          echo "üîë Tester management key ID: $TESTER_KEY_ID"

          # Install Fastlane
          echo "üì¶ Installing Fastlane..."
          sudo gem install fastlane --no-document

          # Verify Fastlane installation
          fastlane --version

          # Create API key file from tester management secret
          mkdir -p ~/.appstoreconnect/private_keys
          echo "$TESTER_API_KEY" | base64 -d > ~/.appstoreconnect/private_keys/AuthKey_$TESTER_KEY_ID.p8
          chmod 600 ~/.appstoreconnect/private_keys/AuthKey_$TESTER_KEY_ID.p8

          # Verify API key file was created correctly
          if [ ! -f ~/.appstoreconnect/private_keys/AuthKey_$TESTER_KEY_ID.p8 ]; then
            echo "‚ùå Failed to create API key file"
            exit 1
          fi

          echo "‚úÖ API key file created: AuthKey_$TESTER_KEY_ID.p8"
          echo "üìè File size: $(wc -c < ~/.appstoreconnect/private_keys/AuthKey_$TESTER_KEY_ID.p8) bytes"

          # Create fastlane directory structure (required by Fastlane)
          mkdir -p fastlane

          # Export environment variables for Fastlane
          export TESTER_KEY_ID="$TESTER_KEY_ID"
          export APP_STORE_CONNECT_ISSUER_ID="$APP_STORE_CONNECT_ISSUER_ID"
          export BUNDLE_ID="$BUNDLE_ID"
          export TESTFLIGHT_TESTERS="$TESTFLIGHT_TESTERS"

          echo "üîç Debug: Environment variables for tester management:"
          echo "   TESTER_KEY_ID: $TESTER_KEY_ID"
          echo "   APP_STORE_CONNECT_ISSUER_ID: $APP_STORE_CONNECT_ISSUER_ID"
          echo "   BUNDLE_ID: $BUNDLE_ID"
          echo "   TESTFLIGHT_TESTERS: $TESTFLIGHT_TESTERS"

          # Create Fastfile with analytics disabled and no interactive prompts
          cat > fastlane/Fastfile << 'EOF'
          # Disable analytics and interactive prompts
          opt_out_usage

          default_platform(:ios)

          platform :ios do
            desc "Add internal testers to TestFlight"
            lane :add_testflight_testers do |options|
              puts "üîß Configuring App Store Connect API..."
              
              # Get values from environment
              key_id = ENV["TESTER_KEY_ID"]
              issuer_id = ENV["APP_STORE_CONNECT_ISSUER_ID"]
              bundle_id = ENV["BUNDLE_ID"]
              testers_string = ENV["TESTFLIGHT_TESTERS"]
              
              puts "üîë Key ID: #{key_id}"
              puts "üÜî Issuer ID: #{issuer_id}"
              puts "üì± Bundle ID: #{bundle_id}"
              puts "üë• Testers to add: #{testers_string}"
              
              if key_id.nil? || key_id.empty?
                puts "‚ùå TESTER_KEY_ID is not set or empty"
                raise "Missing required environment variable: TESTER_KEY_ID"
              end
              
              if issuer_id.nil? || issuer_id.empty?
                puts "‚ùå APP_STORE_CONNECT_ISSUER_ID is not set or empty"
                raise "Missing required environment variable: APP_STORE_CONNECT_ISSUER_ID"
              end
              
              # Build API key configuration hash for direct parameter usage
              api_key_config = {
                key_id: key_id,
                issuer_id: issuer_id,
                key_filepath: "#{Dir.home}/.appstoreconnect/private_keys/AuthKey_#{key_id}.p8"
              }
              
              # Split testers by comma and clean whitespace
              testers = testers_string.split(',').map(&:strip)
              
              # Validate email format
              valid_testers = []
              testers.each do |email|
                if email.match?(/\A[\w+\-.]+@[a-z\d\-]+(\.[a-z\d\-]+)*\.[a-z]+\z/i)
                  valid_testers << email
                else
                  puts "‚ùå Invalid email format: #{email} - skipping"
                end
              end
              
              puts "üìß Valid testers: #{valid_testers.join(', ')}"
              
              if valid_testers.empty?
                puts "‚ùå No valid testers found"
                return
              end
              
              # Try multiple approaches for adding testers
              success_count = 0
              
              valid_testers.each do |email|
                puts "\nüë§ Processing tester: #{email}"
                tester_added = false
                
                # Approach 1: Try pilot with individual tester parameters
                begin
                  puts "üîÑ Approach 1: Using pilot with individual tester..."
                  pilot(
                    api_key: api_key_config,
                    skip_submission: true,
                    skip_waiting_for_build_processing: true,
                    app_identifier: bundle_id,
                    distribute_external: false,
                    email: email,
                    first_name: "Beta",
                    last_name: "Tester"
                  )
                  
                  puts "‚úÖ Success with pilot: #{email}"
                  tester_added = true
                  success_count += 1
                  
                rescue => e
                  puts "‚ö†Ô∏è Pilot approach failed: #{e.message}"
                  
                  # Approach 2: Try using add_beta_tester if available
                  begin
                    puts "üîÑ Approach 2: Checking if tester already exists..."
                    
                    # Since invite_beta_testers doesn't exist, let's just log that the tester might already exist
                    error_msg = e.message.downcase
                    if error_msg.include?("already") || error_msg.include?("exist") || error_msg.include?("duplicate")
                      puts "‚úÖ Tester already exists: #{email}"
                      tester_added = true
                      success_count += 1
                    else
                      puts "‚ùå Could not add tester: #{email}"
                      puts "Error details: #{e.message}"
                      puts "üí° Tester may need to be added manually in App Store Connect"
                    end
                    
                  rescue => e2
                    puts "‚ùå Both approaches failed for #{email}"
                    puts "   Error 1 (pilot): #{e.message}"
                    puts "   Error 2 (fallback): #{e2.message}"
                    puts "üí° Tester may already exist or API key may lack permissions"
                  end
                end
                
                unless tester_added
                  puts "‚ö†Ô∏è Could not confirm tester addition: #{email}"
                  puts "üí° Please check App Store Connect ‚Üí TestFlight ‚Üí Internal Testing"
                end
              end
              
              puts "\nüéâ Tester management completed!"
              puts "‚úÖ Successfully processed: #{success_count}/#{valid_testers.length} testers"
              
              if success_count == valid_testers.length
                puts "üåü All testers added successfully!"
              elsif success_count > 0
                puts "‚ö†Ô∏è Some testers were added, but #{valid_testers.length - success_count} failed"
                puts "üí° Failed testers may already be in TestFlight"
              else
                puts "‚ö†Ô∏è No testers could be added"
                puts "üí° This might be expected if testers are already added"
                puts "üí° Check TestFlight in App Store Connect to verify"
              end
            end
          end
          EOF

          # Create Appfile to prevent Fastlane from asking questions
          cat > fastlane/Appfile << EOF
          # Disable interactive prompts
          app_identifier("$BUNDLE_ID")
          EOF

          echo "üîç Testing API connection with App Manager key..."
          # Run Fastlane to add testers
          echo "üèÉ Running Fastlane to manage testers..."
          if TESTER_KEY_ID="$TESTER_KEY_ID" \
             APP_STORE_CONNECT_ISSUER_ID="$APP_STORE_CONNECT_ISSUER_ID" \
             BUNDLE_ID="$BUNDLE_ID" \
             TESTFLIGHT_TESTERS="$TESTFLIGHT_TESTERS" \
             fastlane ios add_testflight_testers; then
            echo "‚úÖ Fastlane tester management completed successfully!"
          else
            echo "‚ö†Ô∏è Fastlane tester management had some issues, but continuing..."
            echo "üí° Testers may need to be added manually in App Store Connect"
          fi

          # Clean up
          rm -rf fastlane
          rm -f ~/.appstoreconnect/private_keys/AuthKey_$TESTER_KEY_ID.p8

          echo "üéØ TestFlight tester management finished"

      # Upload IPA as artifact backup
      - name: Upload IPA artifact
        uses: actions/upload-artifact@v4
        with:
          name: ios-testflight-ipa
          path: ${{ env.IPA_PATH }}
          retention-days: 7

      # Build Summary
      - name: Build Summary
        run: |
          echo "üéâ iOS TestFlight Build Complete!"
          echo "üì± Bundle ID: ${{ env.BUNDLE_ID }}"
          echo "üì± App Name: ${{ env.APP_NAME }}"
          echo "üì± Marketing Version: ${{ env.MARKETING_VERSION }}"
          echo "üî¢ Bundle Version: ${{ env.BUNDLE_VERSION }}"
          echo "üèÉ GitHub Run Number: ${{ github.run_number }}"
          echo "üîê Signed with: Apple Distribution (${{ secrets.APPLE_TEAM_ID }})"
          echo "üöÄ Uploaded via: Fastlane upload_to_testflight (Developer API key)"
          echo "üë• Tester Management via: Fastlane pilot (App Manager API key)"
          echo "‚úàÔ∏è Uploaded to TestFlight successfully"
          echo "‚è±Ô∏è Build will be available for internal testing in 5-15 minutes"
          echo "üîó Check status: https://appstoreconnect.apple.com/apps"
          echo ""
          echo "üìã Unified Fastlane Approach:"
          echo "   ‚Ä¢ Validation: Both API keys tested with appropriate Fastlane actions"
          echo "   ‚Ä¢ Upload: Developer key with upload_to_testflight (future-proof)"
          echo "   ‚Ä¢ Tester Management: App Manager key with pilot (proper permissions)"
          echo "   ‚Ä¢ Deprecation Ready: No more xcrun altool dependency"
